# 



简述：

在tcp的应用中，都是以二机制字节的形式来对数据做传输。

一般会针对业务协议构造对应的数据结构／数据对象，然后在使用的时候针对协议转换成二进制数据发送给服务端。

但是我们在不同的app中，不同的业务场景使用不同的tcp协议，这样每次socket模块的重用性就特别差，即使是完全一样的底层内容，也因为实现的时候耦合性太高，而导致需要全部重新开发。为了实现模块化的重用，我仿照mina和netty，引入编码器和解码器。


接口框架设计：

为了后续扩展和自定义实现自己的编码器／解码器，有了以下的设计接口。


数据包

数据包基本接口定义（ RHSocketPacket.h）：
数据包内容接口定义（RHSocketPacketContent.h）：(增加timeout超时字段，主要是针对发送的数据包)

tcp编码器
编码器接口定义（ RHSocketEncoderProtocol.h）：

tcp解码器

解码器接口定义（ RHSocketDecoderProtocol.h）：


ok，经过几次调整，程序员内心无数次纠结后，接口定义终于完成了，接下来我们看看怎么组合使用。

前面的socket connection在使用时，还是需要实现delegate的委托方法的，

在不同的app间使用还是需要copy，再实现数据［编码］、［解码］、［分发］，

然后才到对应的场景。其实在［编码］、［分发］之前都是可以模块化独立的，我们就从这里入手。

架构整合调用
首先引入一个service，来帮我们做［连接］、［编码］、［解码］、［分发］的事情。

废话不多说，直接贴代码。



代码调用方法和过程说明：

1-通过startServiceWithHost方法，可实现对服务器的连接。

2-客户端给服务端发送数据，在连接成功后，可以调用asyncSendPacket方法发送数据包。也可以通过notification发送kNotificationSocketPacketRequest通知，发送数据包。在发送数据的过程中，会通过编码器，编码完成后通过connection发送给服务端。

3-服务端向客户端推送数据，会触发didReceiveData方法的回调，通过解码器，解码完成后发出通知给对应的分发器（分发器针对业务调整实现）


代码中是默认的解码器和编码器，针对数据中的分隔符处理，也可以自定义分隔符和数据帧的最大值，代码如下：



分隔符编码器
RHSocketDelimiterEncoder.h文件：

分隔符解码器

RHSocketDelimiterDecoder.h文件：



